<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-us">
  <title>Resumé-Driven Development</title>
  <subtitle></subtitle>
  <id>https://www.kriskelly.me/</id>
  <author>
    <name>Resumé-Driven Development</name>
    <uri>https://www.kriskelly.me/</uri>
  </author>
  <rights>Kris Kelly</rights>
  <icon>https://www.kriskelly.me/image/brand/icon-1-1.png</icon>
  <logo>https://www.kriskelly.me/image/brand/icon-2-1.png</logo>
  <updated>2020-08-19T17:33:56Z</updated>
  <link rel="self" type="application/atom+xml" href="https://www.kriskelly.me/feed.atom" hreflang="en-us"/>
  <link rel="alternate" type="text/html" href="https://www.kriskelly.me/" hreflang="en-us"/>
  <entry>
    <title>Debugging Go with Delve and Tilt</title>
    <author>
      <name>Kris Kelly</name>
      <uri></uri>
    </author>
    <id>https://www.kriskelly.me/go-dlv-tilt-debugging/</id>
    <updated>2020-08-19T16:00:32Z</updated>
    <published>2020-08-19T16:00:32Z</published>
    <content type="html"><![CDATA[<p>If you've been following my tutorial series as a handful of you have been, you'll probably have run into a few WTF moments here and there; the kind of moments where you just want to give up and go play non-violent video games, or sing sad karaoke songs by yourself, or whatever it is that people do when they are upset. But it's ok to feel feelings. You just have to eventually put those feelings aside, because we have work to do!</p>
<p>I'm going to make the (potentially unfounded) assumption that you've used a debugger before. That makes my job easier, because I don't have to explain breakpoints, or stepping through code, or the sense of godlike power that courses through your veins when you finally find the bug after many hours of banging your head against the desk. But if you've never experienced that feeling, here's a <a href="https://golangbot.com/debugging-go-delve/">good tutorial on how to actually use the Go debugger</a>.</p>
<p>The tutorial above is super helpful for actually learning how to debug in Go, so I recommend reading it for the general gist of how to use the debugger itself. I also recommend reading it because I'm too lazy to regurgitate any of it. What I didn't find on the internet though was a concise explanation of how to debug Go via Kubernetes and Tilt, or more generally how to debug Go within a running Docker container. That's the point of this tutorial, and it's (hopefully) short and sweet.</p>
<p>Anyway, as you might have determined from the link above, the Go debugger is called Delve. You can download it thusly:</p>
<pre><code>$ go get github.com/go-delve/delve/cmd/dlv
</code></pre><p>If you've been following along with my tutorial, you can debug the app in your terminal like so:</p>
<pre><code>$ dlv debug cmd/api.go
</code></pre><p>But that is assuming we are running and debugging the app via the terminal. In this set of tutorials, we are using a tool called Tilt which helps you manage a Kubernetes cluster for local development. So instead of running <code>dlv debug</code> in our terminal, we need to run our app via the debug server within our Docker container. Once we've set that up correctly, we should be able to connect to the debug server either via the terminal or via our favorite IDE. I'll show you how to do that via the terminal as well as with VSCode, my current favorite editor.</p>
<p>First things first: we need to modify our <code>Dockerfile</code> to run the dlv debug server. I did this by copying the existing <code>Dockerfile</code> to <code>Dockerfile.debug</code>, a file that is going to match the existing one except for a couple of lines:</p>
<div class="highlight"><pre class="chroma"><code class="language-Dockerfile" data-lang="Dockerfile">...<span class="err">
</span><span class="err"></span><span class="k">COPY</span> go.mod .<span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">RUN</span> go mod download<span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c"># ADDED THIS LINE BELOW</span><span class="err">
</span><span class="err"></span><span class="k">RUN</span> go get github.com/go-delve/delve/cmd/dlv<span class="err">
</span><span class="err">
</span><span class="err"></span><span class="k">COPY</span> . .<span class="err">
</span><span class="err">
</span><span class="err"></span><span class="c"># MODIFIED THE go build COMMAND HERE</span><span class="err">
</span><span class="err"></span><span class="k">RUN</span> go build -gcflags <span class="s2">&#34;-N -l&#34;</span> -o /app/build/api /app/cmd<span class="err">
</span><span class="err">
</span><span class="err"></span>...<span class="err">
</span></code></pre></div><p>The first line installs Delve in our docker container, and the second line disables compiler optimizations, which will make it easier for us to see what we are debugging.</p>
<p>Now that we've got our special Dockerfile for debugging, we need to modify our <code>Tiltfile</code> to use the new Dockerfile and run the Delve debug server. If you've been following the tutorial, you can add something like this to your <code>Tiltfile</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="n">docker_build_with_restart</span><span class="p">(</span><span class="s1">&#39;dating-app/api&#39;</span><span class="p">,</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span>
    <span class="n">dockerfile</span><span class="o">=</span><span class="s1">&#39;./Dockerfile.debug&#39;</span><span class="p">,</span>
    <span class="n">entrypoint</span><span class="o">=</span><span class="s1">&#39;$GOPATH/bin/dlv --listen=:40000 --api-version=2 --headless=true exec /app/build/api&#39;</span><span class="p">,</span>
    <span class="n">ignore</span><span class="o">=[</span><span class="s1">&#39;./Dockerfile&#39;</span><span class="p">,</span> <span class="s1">&#39;.git&#39;</span><span class="o">]</span><span class="p">,</span>
    <span class="n">live_update</span><span class="o">=[</span>
        <span class="n">sync</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;/app&#39;</span><span class="p">),</span>
        <span class="n">run</span><span class="p">(</span><span class="s1">&#39;go build -gcflags &#34;-N -l&#34; -o /app/build/api /app/cmd&#39;</span><span class="p">),</span>
    <span class="o">]</span>
<span class="p">)</span>
<span class="o">...</span>
</code></pre></div><p>This will replace the earlier call to <code>docker_build_with_restart()</code> that we had in there before. The difference between the earlier one and this one is:</p>
<ul>
<li>Using the new dockerfile <code>dockerfile='./Dockerfile.debug'</code></li>
<li>Running the Delve server instead of the app by itself: <code>entrypoint='$GOPATH/bin/dlv --listen=:40000 --api-version=2 --headless=true exec /app/build/api'</code></li>
<li>Changing the <code>go build</code> command to run without compiler optimizations, same way we had it in the new Dockerfile</li>
</ul>
<p>Here we run the Delve server on port 40000, so we need to make sure that that port is exposed properly so that we can access it from outside the Kubernetes cluster. I've got my exposed ports listed in the <code>deployments/api.yaml</code> file, so go ahead and add the appropriate port in there:</p>
<div class="highlight"><pre class="chroma"><code class="language-yaml" data-lang="yaml"><span class="k">spec</span><span class="p">:</span><span class="w">
</span><span class="w">  </span><span class="k">containers</span><span class="p">:</span><span class="w">
</span><span class="w">    </span>- <span class="k">name</span><span class="p">:</span><span class="w"> </span>api<span class="w">
</span><span class="w">      </span><span class="k">image</span><span class="p">:</span><span class="w"> </span>dating-app/api<span class="w">
</span><span class="w">      </span><span class="k">command</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&#34;/app/build/api&#34;</span><span class="p">]</span><span class="w">
</span><span class="w">      </span><span class="k">ports</span><span class="p">:</span><span class="w">
</span><span class="w">        </span>- <span class="k">containerPort</span><span class="p">:</span><span class="w"> </span><span class="m">3000</span><span class="w">
</span><span class="w">        </span>- <span class="k">containerPort</span><span class="p">:</span><span class="w"> </span><span class="m">40000</span><span class="w"> </span><span class="c"># &lt;-- Add this</span><span class="w">
</span></code></pre></div><p>You'll also need to make sure the port is exposed on the Kubernetes resource in Tilt, so go ahead and add it there as well:</p>
<div class="highlight"><pre class="chroma"><code class="language-ruby" data-lang="ruby"><span class="c1"># Change port_forwards to include 40000</span>
<span class="n">k8s_resource</span><span class="p">(</span><span class="s1">&#39;api&#39;</span><span class="p">,</span> <span class="n">port_forwards</span><span class="o">=[</span><span class="mi">3000</span><span class="p">,</span> <span class="mi">40000</span><span class="o">]</span><span class="p">)</span>
</code></pre></div><p>Once you've done that and Tilt has done its thing, you should be able to connect the debugger in your favorite IDE. Mine is VSCode, so I'll throw in an example launch config. If you're using VSCode, add the following to your <code>launch.json</code> config:</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json">    <span class="err">...</span>

    <span class="s2">&#34;configurations&#34;</span><span class="err">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;Attach to Delve&#34;</span><span class="p">,</span>
      <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="s2">&#34;go&#34;</span><span class="p">,</span>
      <span class="nt">&#34;request&#34;</span><span class="p">:</span> <span class="s2">&#34;attach&#34;</span><span class="p">,</span>
      <span class="nt">&#34;mode&#34;</span><span class="p">:</span> <span class="s2">&#34;remote&#34;</span><span class="p">,</span>
      <span class="nt">&#34;port&#34;</span><span class="p">:</span> <span class="mi">40000</span>
    <span class="p">}</span>
  <span class="p">]</span>
</code></pre></div><p>Once that's done, you should be able to run the &quot;Attach to Delve&quot; command in the VSCode debugger tab, and once you've connected, be sure to <code>continue</code> the app execution so that it actually starts the web server we are trying to debug.</p>
<p>If you don't have or want to use an IDE for debugging, you can just as easily connect to the running Delve server via the terminal:</p>
<pre><code>$ dlv connect localhost:40000 --api-version=2
</code></pre><p>And that's that. Be sure to set a breakpoint before you run <code>continue</code>, try this for instance:</p>
<pre><code>(dlv) break github.com/kriskelly/dating-app-example/internal/graph.Signup
</code></pre><p>That way, when you run <code>continue</code> start the server execution, you can then run the <code>Signup</code> mutation in the GraphQL playground and it should hit the breakpoint in the resolver.</p>
<p>Congratulations, now you have enough info to debug your Go application. Go forth and correct all the mistakes I've inadvertently put into the example code in these tutorials. And good luck!</p>]]></content>
  </entry>
  <entry>
    <title>Resumé-Driven Development Part 3: Dgraph because it sounds cool</title>
    <author>
      <name>Kris Kelly</name>
      <uri></uri>
    </author>
    <id>https://www.kriskelly.me/part3-go-dgraph/</id>
    <updated>2020-08-11T05:00:00Z</updated>
    <published>2020-08-11T05:00:00Z</published>
    <content type="html"><![CDATA[<p>So <a href="/part2-go-graphql">last time</a> we started building our app as a GraphQL API with some basic user endpoints. But it had no database, which was fine for demonstration purposes, though none of the user data that we put into the system was actually being stored. We need a database to store our precious data, so that we can mine it for nefarious business purposes later on.</p>
<p>But this tutorial won't cover any of the various ways in which companies mine your data for $$$. If I knew how to do that, I wouldn't be here writing blog posts <em>ZING</em>. For now we are innocently building a database of user data in order to be able to model the relationships between our users, to track when users like/match each other, who lives in the same city, etc. etc. We could certainly do this the old-fashioned way, by spinning up a traditional database like MySQL or Postgres and dumping the data into tables. How boring, how practical!</p>
<p>What we are going to do instead is utilize a fancy graph database I found on the internet called <a href="https://dgraph.io/">Dgraph</a>. If you've got a technical background, you're probably familiar with the concept of a graph database. But as I mentioned in an earlier part of this tutorial, I am going to pretend that you are not.</p>
<p>Graph databases are cool because instead of modeling data as rows in a table, you model it as a graph, i.e. with nodes and edges. For instance, instead of a user being represented by a row in a <code>users</code> table, with fields called name, email, etc. we model an individual user as a node in the graph, and each of the edges corresponds to some data about the user. There's a &quot;name&quot; edge, an &quot;email&quot; edge, etc. This gets interesting when the edges start pointing to other nodes, e.g. an edge called <code>likes</code> that points to another user that the first user &quot;liked&quot; via the app.</p>
<p>As to why we would do this, I think the simplest explanation is that any dataset with a high number of relationships amongst the various data points is better represented in a format where we can trace those relationships effectively. Do you have a family tree modeled as a graph, and you want to know the names of all your second cousins? There are so many of them, it's hard to keep track, right? I mean, I have that list above my bed but even then I can barely distinguish between the ones on the &quot;love&quot; list and the ones on the &quot;hate&quot; list. What a conundrum, right?</p>
<p>Well if you modeled that data as a graph, you could easily trace your second cousins, as well as all your &quot;friends&quot; from middle school, then you could add an edge for <code>hated_by_me</code> that pointed from your user to them, and then next time you would just need to traverse the <code>hated_by_me</code> edges to easily keep track of all the friends and family members that you want to remember to hate.</p>
<p>You could do this with a traditional database, but you'd have to store that data in a set of tables that modeled the relationships between users, and then you'd need to write a query to self-join against the <code>users</code> table umpteen times to traverse the graph of that data. Definitely doable, but fairly inefficient.</p>
<p>So along comes Dgraph. Dgraph sells itself as a &quot;native GraphQL database&quot;, which not only sounds cool, but is also a good fit for what we are doing now, seeing as we are building a GraphQL API. As such, the queries that we make to Dgraph will ultimately end up looking very similar to the ones we make to our API.</p>
<p>So anyway, let's get started with Dgraph. There are a whole bunch of ways to <a href="https://dgraph.io/downloads#download-kubernetes">install the thing</a>, but since we already have our local Kubernetes cluster up and running, we are going to take that approach and download the simplest Kubernetes config file they that they have available. Go ahead and download this file into our <code>deployments/</code> directory:</p>
<pre><code>$ wget https://raw.githubusercontent.com/dgraph-io/dgraph/master/contrib/config/kubernetes/dgraph-single/dgraph-single.yaml -O deployments/dgraph-single.yaml
</code></pre><p>Now add it to our <code>Tiltfile</code>:</p>
<pre><code>k8s_yaml('deployments/api.yaml')
k8s_yaml('deployments/dgraph-single.yaml') # &lt;-- Add this line

docker_build_with_restart('dating-app/api', '.',
...

k8s_resource('api', port_forwards=[3000])
k8s_resource('dgraph', port_forwards=[9080]) # &lt;-- And this one
</code></pre><p>Now you should see a new entry for <code>dgraph</code> in the Tilt console, and if you're lucky, it should be spitting out a bunch of nonsense garbage that you don't need to understand. That's just Kubernetes setting up the dgraph cluster and getting the processes up and running. If you see errors instead, and the dgraph entry is all red and error-y, then you've got a problem. Please pick up the phone and dial emergency services and tell them &quot;the database is broken&quot;. Say only those words, and make sure to repeat slowly if they ask for clarification. Just kidding, don't call 911 without a real emergency! And there's your PSA for the day.</p>
<p>Now that we've got Dgraph up and running, the next thing we need to do is set up our Dgraph database schema.</p>
<p>First we need to grab a couple of dependencies:</p>
<pre><code>$ go get github.com/dgraph-io/dgo/v2
$ go get google.golang.org/grpc
</code></pre><p><code>dgo</code> is the Dgraph Go API client, and <code>grpc</code> is a fancy tool originally created by Google that we use to communicate across service boundaries. <a href="https://grpc.io/docs/what-is-grpc/introduction/">Here's a nice introduction</a>, if you're interested. If you're familiar with REST already, then here's a confusing explanation: RPC means &quot;remote procedure call&quot;, and at one point REST was the new hotness that more or less replaced RPC, but now RPC has replaced REST in the sense that gRPC is gaining traction, so now the old thing is new again. Confused? Good! Let's continue.</p>
<p>Next, let's make a file called <code>internal/dgraph/client.go</code> and put the following in there:</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kn">package</span> <span class="nx">dgraph</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;flag&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;os&#34;</span>

	<span class="s">&#34;github.com/dgraph-io/dgo/v2&#34;</span>
	<span class="s">&#34;github.com/dgraph-io/dgo/v2/protos/api&#34;</span>

	<span class="s">&#34;google.golang.org/grpc&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">dgraph</span> <span class="p">=</span> <span class="nx">flag</span><span class="p">.</span><span class="nf">String</span><span class="p">(</span><span class="s">&#34;d&#34;</span><span class="p">,</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getenv</span><span class="p">(</span><span class="s">&#34;DGRAPH_HOST&#34;</span><span class="p">),</span> <span class="s">&#34;Dgraph Alpha address&#34;</span><span class="p">)</span>
<span class="p">)</span>

<span class="c1">// Client is our Dgraph API wrapper
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Client</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">conn</span> <span class="o">*</span><span class="nx">grpc</span><span class="p">.</span><span class="nx">ClientConn</span>
	<span class="o">*</span><span class="nx">dgo</span><span class="p">.</span><span class="nx">Dgraph</span>
<span class="p">}</span>

<span class="c1">// NewClient generates an instance of our client
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewClient</span><span class="p">()</span> <span class="o">*</span><span class="nx">Client</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Client</span><span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// Connect to GRPC
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Client</span><span class="p">)</span> <span class="nf">Connect</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">flag</span><span class="p">.</span><span class="nf">Parse</span><span class="p">()</span>
	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="o">*</span><span class="nx">dgraph</span><span class="p">,</span> <span class="nx">grpc</span><span class="p">.</span><span class="nf">WithInsecure</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">conn</span> <span class="p">=</span> <span class="nx">conn</span>
	<span class="nx">c</span><span class="p">.</span><span class="nx">Dgraph</span> <span class="p">=</span> <span class="nx">dgo</span><span class="p">.</span><span class="nf">NewDgraphClient</span><span class="p">(</span><span class="nx">api</span><span class="p">.</span><span class="nf">NewDgraphClient</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">conn</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">// Close the connection
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Client</span><span class="p">)</span> <span class="nf">Close</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div><p>Now let's make a new executable called <code>cmd/dgraph/setup.go</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;context&#34;</span>
	<span class="s">&#34;io/ioutil&#34;</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;path/filepath&#34;</span>

	<span class="s">&#34;github.com/dgraph-io/dgo/v2/protos/api&#34;</span>
	<span class="s">&#34;github.com/kriskelly/dating-app-example/internal/dgraph&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">readSchema</span><span class="p">()</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
	<span class="nx">wd</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getwd</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">path</span> <span class="o">:=</span> <span class="nx">filepath</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="nx">wd</span><span class="p">,</span> <span class="s">&#34;./internal/dgraph/dgraph.graphqls&#34;</span><span class="p">)</span>
	<span class="nx">b</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nf">ReadFile</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatalln</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">b</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Setting up the Dgraph schema...&#34;</span><span class="p">)</span>

	<span class="nx">client</span> <span class="o">:=</span> <span class="nx">dgraph</span><span class="p">.</span><span class="nf">NewClient</span><span class="p">()</span>
	<span class="nx">client</span><span class="p">.</span><span class="nf">Connect</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
	<span class="nx">op</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">api</span><span class="p">.</span><span class="nx">Operation</span><span class="p">{}</span>
	<span class="nx">op</span><span class="p">.</span><span class="nx">Schema</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nf">readSchema</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Alter</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">op</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Ran Alter Schema on DGraph&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>And finally, let's make a schema file called <code>internal/dgraph/dgraph.graphqls</code>:</p>
<pre><code>name: string @index(exact, fulltext) @count .
email: string @index(exact) .
password: password .
liked: [uid] @count @reverse .
rejected: [uid] @count @reverse .
matched: [uid] @count @reverse .
lives_in: uid @reverse .

type User {
    name
    email
    password
    matched
    liked
    rejected
    lives_in
}

type City {
    name
}
</code></pre><p>The code in <code>client.go</code> just wraps our <code>dgo</code> API client with some additional code to make and close a connection to the Dgraph server. Our <code>dgraph.graphqls</code> file defines the database schema that we'll be using, and we'll go over that in a bit. The <code>setup.go</code> glues these things together; it reads the schema file, opens a database connection, and runs an <code>Alter</code> operation to modify the schema to match our schema file, like so:</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang">	<span class="nx">op</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">api</span><span class="p">.</span><span class="nx">Operation</span><span class="p">{}</span>
	<span class="nx">op</span><span class="p">.</span><span class="nx">Schema</span> <span class="p">=</span> <span class="nb">string</span><span class="p">(</span><span class="nf">readSchema</span><span class="p">())</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">client</span><span class="p">.</span><span class="nf">Alter</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="nx">op</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
	<span class="p">}</span>
</code></pre></div><p>Now we can dig into the schema file itself. The first thing this file does is define the data types for the different kinds of edges that we can have for our users:</p>
<pre><code>name: string @index(exact, fulltext) @count .
email: string @index(exact) .
password: password .
liked: [uid] @count @reverse .
rejected: [uid] @count @reverse .
matched: [uid] @count @reverse .
lives_in: uid @reverse .
</code></pre><p>Some of this might seem self-explanatory. For instance, <code>name: string</code> tells us that the name field should be a string. For the other fields, <code>[uid]</code> indicates that the edge corresponds to an array of nodes, in this case other users. So in this way we can keep track of who liked/rejected who, where people live, etc.</p>
<p>The <code>@index</code>, <code>@count</code>, etc. parts correspond to database indexes for those fields. <code>@count</code> indexes the count, so we could for instance retrieve the number of users with a specific name. <code>fulltext</code> operates similar to a full-text index in Postgres or MySQL, and <code>@reverse</code> sets up an index that allows us to look up nodes in reverse. That means that instead of having to have a separate edge for <code>liked_by</code>, we could just look up a list of all the users who liked us by checking to see where there's a <code>liked</code> edge that points to us.</p>
<p>The rest of the schema file defines the various data types for our nodes. In this case we just have <code>User</code> and <code>City</code>:</p>
<pre><code>type User {
    name
    email
    password
    matched
    liked
    rejected
    lives_in
}

type City {
    name
}
</code></pre><p>Types are basically defined similarly to GraphQL, which fits in with Dgraph's branding as a GraphQL database. I'm not entirely sure what happens if you try to create a user with an edge that is not defined on the type, but I'll do that at some point and report back.</p>
<p>Now that we've got our code set up properly to create the database schema, let's run it on the command line. Note that we are not container-izing this script just yet, as it's more of a one-off. For now we can just run it in the terminal:</p>
<div class="highlight"><pre class="chroma"><code class="language-bash" data-lang="bash">$ <span class="nv">DGRAPH_HOST</span><span class="o">=</span>localhost:9080 go run cmd/dgraph/setup.go
</code></pre></div><p>Couple of things to note about this: we specify the Dgraph host via an environment variable (which we referenced in <code>client.go</code> earlier), and that environment variable points to a port we exposed on localhost earlier in our <code>Tiltfile</code>. Doing this sort of thing allows us to access any service that runs on our Kubernetes cluster as though we were running it outside the confines of the cluster, essentially so that we can poke at the database at our leisure to do things like setting up the schema, verifying the data, etc. We'll look into examining the data later on.</p>
<p>For now, if you run the script above, you should see a message indicating that the schema was altered. Congratulations to both of us! Congratulations to you for managing to follow my instructions, and also congratulations to me for not f'ing up the instructions. Wins all around.</p>
<p>Anyway, because everyone's attention span these days is about as long as my middle finger, I'm going to try to keep these posts short and sweet. We've successfully set up our Dgraph database and schema, so the next post is going to be all about querying Dgraph and the various ways of making it do our bidding. See you next week!</p>]]></content>
  </entry>
  <entry>
    <title>Resumé-Driven Development Part 2: Implementing a GraphQL server in Go</title>
    <author>
      <name>Kris Kelly</name>
      <uri></uri>
    </author>
    <id>https://www.kriskelly.me/part2-go-graphql/</id>
    <updated>2020-08-04T01:00:00Z</updated>
    <published>2020-08-04T01:00:00Z</published>
    <content type="html"><![CDATA[<p>Welcome to Part 2 of this tutorial series. In the <a href="/part1-go-k8s/">last section</a>, we started by setting up a basic Go service running in a Kubernetes development environment because, as we've previously established, Kubernetes is a required component of resumé-driven development. In this part of the tutorial, we incorporate another well-known buzzworthy technology called GraphQL because, well, because we are tired of the <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">tried-and-true approach</a>.</p>
<p>If you're reading this, you've most likely heard of GraphQL, but if not then I recommend you read this entire website from start to finish: <a href="https://graphql.org/">GraphQL.org</a>. Or just skim the first couple of pages or something. We've got work to do!</p>
<p>So now we're going to set up a GraphQL server with a very simple implementation of signup and login for our users. We'll start by adding the <a href="https://gqlgen.com/">gqlgen</a> library to our project. They've got a good &quot;Getting Started&quot; tutorial which we will basically be following for the first part of this.</p>
<pre><code>$ cd dating-app-example
$ go get github.com/99designs/gqlgen
</code></pre><p>At this point we could continue following the gqlgen tutorial and run <code>go run github.com/99designs/gqlgen init</code> to initialize the project structure, but since we have our own opinions about how the project should be structured, let's start with a custom config file and use that to generate the code we need.</p>
<p>Copy the following config into a <code>gqlgen.yml</code> file in the root of the project:</p>
<pre><code># Where are all the schema files located? globs are supported eg  src/**/*.graphqls
schema:
  - internal/graph/*.graphqls

# Where should the generated server code go?
exec:
  filename: internal/graph/generated/generated.go
  package: generated

# Where should any generated models go?
model:
  filename: internal/model/models_gen.go
  package: model

# Where should the resolver implementations go?
resolver:
  layout: follow-schema
  dir: internal/graph
  package: graph

# gqlgen will search for any type names in the schema in these go packages
# if they match it will use them, otherwise it will generate them.
autobind:
  - &quot;github.com/kriskelly/dating-app-example/internal/model&quot;

# This section declares type mapping between the GraphQL and go type systems
#
# The first line in each type will be used as defaults for resolver arguments and
# modelgen, the others will be allowed when binding to fields. Configure them to
# your liking
models:
  ID:
    model:
      - github.com/99designs/gqlgen/graphql.ID
      - github.com/99designs/gqlgen/graphql.Int
      - github.com/99designs/gqlgen/graphql.Int64
      - github.com/99designs/gqlgen/graphql.Int32
  Int:
    model:
      - github.com/99designs/gqlgen/graphql.Int
      - github.com/99designs/gqlgen/graphql.Int64
      - github.com/99designs/gqlgen/graphql.Int32

</code></pre><p>The auto-generated comments in this file do a good job of explaining each setting, but the gist is that we are just modifying the paths to point to <code>internal/graph</code> and <code>internal/model</code> as the locations for our GraphQL resolvers and models, respectively. The important thing to remember is that I did this before without configuring any of the directories, and then I got confused about why my app had multiple sets of models, and then I got angry, and then I took a nap. The End.</p>
<p>Before we generate any code, let's also specify the GraphQL schema that we want to build by putting the following in <code>internal/graph/schema.graphqls</code>:</p>
<pre><code>type User {
  id: ID!
  name: String!
  email: String!
  password: String!
}

type Query {
  me: User!
}

input NewUser {
  name: String!
  email: String!
  password: String!
}

type Mutation {
  login(email: String!, password: String!): User!
  signup(input: NewUser!): User!
}
</code></pre><p>This defines enough types, mutations, and queries to get us through a basic signup/login flow for a user.</p>
<p>One last thing to do before we generate any code is to define our User model. Because we specified the <code>autobind</code> setting in our config file, <code>gqlgen</code> will look for models that we have defined ourselves and use those instead of auto-generating that code. So let's define our own User model first in <code>internal/model/user.go</code>:</p>
<pre><code>package model

// User model
type User struct {
	ID       string `json:&quot;id&quot;`
	Name     string `json:&quot;name&quot;`
	Email    string `json:&quot;email&quot;`
	Password string `json:&quot;password&quot;`
}
</code></pre><p>The list of fields here matches what we declared in our GraphQL schema. The JSON annotation names should also match the names of fields in the schema. Now let's generate the code for the <a href="https://www.tutorialspoint.com/graphql/graphql_resolver.htm">resolvers</a>:</p>
<pre><code>$ go run github.com/99designs/gqlgen
</code></pre><p>This will generate some files in <code>internal/graph</code>, one of which is <code>schema.resolvers.go</code>. Let's talk a look at this file first. There you'll see some stubs for resolvers, for example:</p>
<pre><code>func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.User, error) {
	panic(fmt.Errorf(&quot;not implemented&quot;))
}
</code></pre><p>This is where the bulk of our resolver logic will go. Note the presence of the <code>panic</code> function which, when called, causes the app to blow up. But let's not worry about that just yet. We've got a few more steps before we get a live GraphQL server up and running. Let's modify our original <code>api.go</code> file to serve the GraphQL API. Note that this is fairly similar to the code that gets generated if you had initialized the project using <code>go run github.com/99designs/gqlgen init</code>:</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;net/http&#34;</span>
	<span class="s">&#34;os&#34;</span>
	<span class="s">&#34;time&#34;</span>

	<span class="s">&#34;github.com/99designs/gqlgen/graphql/handler&#34;</span>
	<span class="s">&#34;github.com/99designs/gqlgen/graphql/playground&#34;</span>
	<span class="s">&#34;github.com/alexedwards/scs/v2&#34;</span>
	<span class="s">&#34;github.com/kriskelly/dating-app-example/internal/graph&#34;</span>
	<span class="s">&#34;github.com/kriskelly/dating-app-example/internal/graph/generated&#34;</span>
<span class="p">)</span>

<span class="kd">const</span> <span class="nx">defaultPort</span> <span class="p">=</span> <span class="s">&#34;3000&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">port</span> <span class="o">:=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">Getenv</span><span class="p">(</span><span class="s">&#34;PORT&#34;</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">port</span> <span class="o">==</span> <span class="s">&#34;&#34;</span> <span class="p">{</span>
		<span class="nx">port</span> <span class="p">=</span> <span class="nx">defaultPort</span>
	<span class="p">}</span>

	<span class="nx">sessionManager</span> <span class="o">:=</span> <span class="nx">scs</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="nx">sessionManager</span><span class="p">.</span><span class="nx">Lifetime</span> <span class="p">=</span> <span class="mi">24</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Hour</span>

	<span class="nx">resolver</span> <span class="o">:=</span> <span class="nx">graph</span><span class="p">.</span><span class="nf">NewResolver</span><span class="p">(</span><span class="nx">sessionManager</span><span class="p">)</span>
	<span class="nx">srv</span> <span class="o">:=</span> <span class="nx">handler</span><span class="p">.</span><span class="nf">NewDefaultServer</span><span class="p">(</span><span class="nx">generated</span><span class="p">.</span><span class="nf">NewExecutableSchema</span><span class="p">(</span><span class="nx">generated</span><span class="p">.</span><span class="nx">Config</span><span class="p">{</span><span class="nx">Resolvers</span><span class="p">:</span> <span class="nx">resolver</span><span class="p">}))</span>

	<span class="nx">mux</span> <span class="o">:=</span> <span class="nx">http</span><span class="p">.</span><span class="nf">NewServeMux</span><span class="p">()</span>
	<span class="nx">mux</span><span class="p">.</span><span class="nf">HandleFunc</span><span class="p">(</span><span class="s">&#34;/&#34;</span><span class="p">,</span> <span class="nx">playground</span><span class="p">.</span><span class="nf">Handler</span><span class="p">(</span><span class="s">&#34;GraphQL playground&#34;</span><span class="p">,</span> <span class="s">&#34;/query&#34;</span><span class="p">))</span>
	<span class="nx">mux</span><span class="p">.</span><span class="nf">Handle</span><span class="p">(</span><span class="s">&#34;/query&#34;</span><span class="p">,</span> <span class="nx">srv</span><span class="p">)</span>

	<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;connect to http://localhost:%s/ for GraphQL playground&#34;</span><span class="p">,</span> <span class="nx">port</span><span class="p">)</span>
	<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nf">ListenAndServe</span><span class="p">(</span><span class="s">&#34;:&#34;</span><span class="o">+</span><span class="nx">port</span><span class="p">,</span> <span class="nx">sessionManager</span><span class="p">.</span><span class="nf">LoadAndSave</span><span class="p">(</span><span class="nx">mux</span><span class="p">)))</span>
<span class="p">}</span>
</code></pre></div><p>There's a lot going on here. You may notice from the <code>imports</code> section at the top that we are using the <code>gqlgen</code> library, but we are also using another library called <a href="https://github.com/alexedwards/scs">scs</a>. As much as I want to say that this is because we are making this unnecessarily complicated, it's actually because it's a pretty useful library for user session management. I wanted to include it in here now rather than backtracking and adding it later.</p>
<p>Now to explain what's happening here: First we create a session manager <code>sessionManager</code>, a GraphQL resolver <code>resolver</code>, and a GraphQL server <code>srv</code>. Next we create a multiplexer <code>mux</code>. For those of us who want to google &quot;multiplexer&quot;, it's just a fancy word for a server that can handle multiple types of requests. In this case, we will be handling requests for our &quot;GraphQL playground&quot;, which is a web UI for making and testing GraphQL requests alongside the GraphQL server itself.</p>
<p>Unfortunately, we can't run this code yet. There are a few more changes that we need to make. Let's start by replacing the contents of our <code>resolver.go</code> file with the following:</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kn">package</span> <span class="nx">graph</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;github.com/alexedwards/scs/v2&#34;</span>
	<span class="s">&#34;github.com/kriskelly/dating-app-example/internal/model&#34;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Resolver</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">users</span>          <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">model</span><span class="p">.</span><span class="nx">User</span>
	<span class="nx">sessionManager</span> <span class="o">*</span><span class="nx">scs</span><span class="p">.</span><span class="nx">SessionManager</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewResolver</span><span class="p">(</span><span class="nx">sessionManager</span> <span class="o">*</span><span class="nx">scs</span><span class="p">.</span><span class="nx">SessionManager</span><span class="p">)</span> <span class="o">*</span><span class="nx">Resolver</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">Resolver</span><span class="p">{</span>
		<span class="nx">users</span><span class="p">:</span>          <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">model</span><span class="p">.</span><span class="nx">User</span><span class="p">),</span>
		<span class="nx">sessionManager</span><span class="p">:</span> <span class="nx">sessionManager</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>This does a couple of things: it adds a <code>users</code> attribute to our resolver for maintaining a list of users that we've created, and it adds an initializer called <code>NewResolver()</code> to ensure that our resolver is initialized correctly. We're going to wind up using that <code>sessionManager</code> that we initialized earlier in our resolver code, so we're passing it to the resolver here. At this point, once we save this file and Tilt reruns the app, we should be able to access the GraphQL server.</p>
<p>Go ahead and open the GraphQL playground in your browser at <code>localhost:3000</code>. Now you should be able to run a query like:</p>
<div class="highlight"><pre class="chroma"><code class="language-graphql" data-lang="graphql"><span class="kd">query</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="nc">me</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="py">id</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>After running this query, you should see an &quot;internal system error&quot; message in the response. If you go back to the Tilt console, you can see the <code>panic()</code> error message printed as a long, scary stack trace starting something like this:</p>
<pre><code>not implemented

goroutine 5 [running]:
runtime/debug.Stack(0x1, 0x0, 0x0)
	/usr/local/go/src/runtime/debug/stack.go:24 +0x9d
runtime/debug.PrintStack()
	/usr/local/go/src/runtime/debug/stack.go:16 +0x22
github.com/99designs/gqlgen/graphql.DefaultRecover(0x93cd60, 0xc00035d290, 0x8181c0, 0xc0003549d0, 0xc000022a80, 0x7fcfbf2077d0)
...
</code></pre><p>Are you panicking yet? Good, because now we have feedback that the system is working end-to-end. Now we can start implementing our resolvers!</p>
<p>Now let's pop over to where we implement our queries and mutations. Replace the relevant functions with the following code:</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">mutationResolver</span><span class="p">)</span> <span class="nf">Login</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">email</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">password</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">model</span><span class="p">.</span><span class="nx">User</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">user</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">users</span><span class="p">[</span><span class="nx">email</span><span class="p">]</span>
	<span class="k">if</span> <span class="nx">user</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Invalid email&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">user</span><span class="p">.</span><span class="nx">Password</span> <span class="o">!=</span> <span class="nx">password</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;Invalid password&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">sessionManager</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;userID&#34;</span><span class="p">,</span> <span class="nx">email</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">user</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">mutationResolver</span><span class="p">)</span> <span class="nf">Signup</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">input</span> <span class="nx">model</span><span class="p">.</span><span class="nx">NewUser</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">model</span><span class="p">.</span><span class="nx">User</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">newUser</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">model</span><span class="p">.</span><span class="nx">User</span><span class="p">{</span>
		<span class="nx">Name</span><span class="p">:</span>     <span class="nx">input</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span>
		<span class="nx">Email</span><span class="p">:</span>    <span class="nx">input</span><span class="p">.</span><span class="nx">Email</span><span class="p">,</span>
		<span class="nx">Password</span><span class="p">:</span> <span class="nx">input</span><span class="p">.</span><span class="nx">Password</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">id</span> <span class="o">:=</span> <span class="nx">uuid</span><span class="p">.</span><span class="nf">New</span><span class="p">().</span><span class="nf">String</span><span class="p">()</span>
	<span class="nx">newUser</span><span class="p">.</span><span class="nx">ID</span> <span class="p">=</span> <span class="nx">id</span>
	<span class="nx">r</span><span class="p">.</span><span class="nx">users</span><span class="p">[</span><span class="nx">newUser</span><span class="p">.</span><span class="nx">Email</span><span class="p">]</span> <span class="p">=</span> <span class="nx">newUser</span>
	<span class="k">return</span> <span class="nx">newUser</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">queryResolver</span><span class="p">)</span> <span class="nf">Me</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">model</span><span class="p">.</span><span class="nx">User</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">userID</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">sessionManager</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="s">&#34;userID&#34;</span><span class="p">).(</span><span class="kt">string</span><span class="p">)</span>
	<span class="nx">user</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">users</span><span class="p">[</span><span class="nx">userID</span><span class="p">]</span>
	<span class="k">if</span> <span class="nx">user</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">errors</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="s">&#34;No current user&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">user</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div><p>You'll see that the <code>Signup()</code> mutation creates a new <code>User</code> instance and caches it in the resolver. <code>Login()</code> does a lookup based on the email address then uses our <code>sessionManager</code> to save the email address in the user session, and <code>Me()</code> looks up the current user based on that user session data. All of this is simplified to work without a database, so it goes without saying that you wouldn't do this in a real app. But for demonstration purposes, you get the gist.</p>
<p>I wanted unique IDs for the users, so I added the <a href="https://github.com/google/uuid">github.com/google/uuid</a> library and generated the ID like so:</p>
<div class="highlight"><pre class="chroma"><code class="language-golang" data-lang="golang"><span class="nx">id</span> <span class="o">:=</span> <span class="nx">uuid</span><span class="p">.</span><span class="nf">New</span><span class="p">().</span><span class="nf">String</span><span class="p">()</span>
</code></pre></div><p>This isn't super useful right now, but it will be useful later on when we start using a database.</p>
<p>Anyway, now you should be able to fire up the GraphQL playground and make some moves. Go ahead and ...make some moves. Try a <code>signup()</code> mutation, followed by <code>login()</code> and <code>me()</code>. For example:</p>
<div class="highlight"><pre class="chroma"><code class="language-graphql" data-lang="graphql"><span class="kd">mutation</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="nc">signup</span><span class="p">(</span><span class="kd">input</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nc">name</span><span class="p">:</span><span class="w"> </span><span class="s">&#34;Foobar&#34;</span><span class="p">,</span><span class="w"> </span><span class="nc">email</span><span class="p">:</span><span class="w"> </span><span class="s">&#34;foo@bar.com&#34;</span><span class="p">,</span><span class="w"> </span><span class="nc">password</span><span class="p">:</span><span class="w"> </span><span class="s">&#34;foo&#34;</span><span class="w"> </span><span class="p">})</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="nc">name</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c"># Then in a separate call:</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="nc">mutation</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="py">login</span><span class="p">(</span><span class="py">email</span><span class="p">:</span><span class="w"> </span><span class="s">&#34;foo@bar.com&#34;</span><span class="p">,</span><span class="w"> </span><span class="nc">password</span><span class="p">:</span><span class="w"> </span><span class="s">&#34;foo&#34;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="nc">name</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="c"># Then:</span><span class="w">
</span><span class="w">
</span><span class="w"></span><span class="kd">query</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">  </span><span class="nc">me</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="w">    </span><span class="py">id</span><span class="w">
</span><span class="w">    </span><span class="py">name</span><span class="w">
</span><span class="w">  </span><span class="p">}</span><span class="w">
</span><span class="w"></span><span class="p">}</span><span class="w">
</span></code></pre></div><p>If all's well, then you've got a functioning GraphQL server!</p>
<p>Be sure to tune in for Part 3, where-in we will integrate Dgraph, a shiny new NoSQL graph database, to store user data and relationships.</p>]]></content>
  </entry>
  <entry>
    <title>Resumé-Driven Development Part 1: Setting up a Golang development environment with Kubernetes and Tilt</title>
    <author>
      <name>Kris Kelly</name>
      <uri></uri>
    </author>
    <id>https://www.kriskelly.me/part1-go-k8s/</id>
    <updated>2020-07-24T00:00:00Z</updated>
    <published>2020-07-24T00:00:00Z</published>
    <content type="html"><![CDATA[<p>So I've never done a blog tutorial series before... or a blog... or written anything longer than a social media post in longer than I care to admit. Naturally, I wanted to start out with something simple... Just kidding! This is going to be complicated.</p>
<p>In this series, we're going to be practicing something called <a href="https://rdd.io/">resumé-driven development</a> (RDD), starting with setting up our development environment and continuing through the basics of incorporating several unnecessary but buzzword-y technologies into our app.</p>
<p>In the process, hopefully you'll learn something without nearly as much frantic googling as I had to do. No familiarity with any of the particular technologies is required. In fact, it's much easier for me to pretend like you haven't heard about any of it. As long as you have a basic understanding of object-oriented programming and backend web development, you should be <del>desperately confused</del> good to go!</p>
<blockquote>DISCLAIMER: While seeming to be satire, this tutorial is actually meant to be useful. If you find it to be neither amusing nor useful, then please film a video of yourself reacting disapprovingly, post it on youtube, send me a link, and I will watch that video as I cry myself to sleep late into the night.</blockquote>
<p>Most of these tutorials involve building a todo app. Todo apps are boring. I'm a firm believer that the projects that motivate us best are the ones in which we &quot;scratch our own itch&quot;, so I've decided to focus on a topic that is an endless source of <del>frustration</del> fascination for me: <em>dating</em>. I think many of us who are unfortunate enough to be single during this time of plague can agree that it's not fun. Anyway instead of learning to be alone or unpacking emotional baggage, let's build a dating app! Or at least, let's take a... <em>swipe</em> at it (I'm so sorry).</p>
<p>When it comes to apps, and particularly dating apps, user experience is everything. Therefore for this tutorial series, we'll be building the API portion that no one will ever see. Because this could otherwise potentially be very boring, we're going to overcomplicate this thing considerably. Thus I've decided to build it as a GraphQL API written in Go, running on Kubernetes, using both a traditional RDBMS (Postgres) and a NoSQL graph database (Dgraph), with a cloud service (AWS S3) thrown in there for good measure. I might do a series in the future about building the frontend app (most likely Next.js + Apollo), but then again, probably not.</p>
<p>Part 1 of this tutorial will involve setting up our project using Go, Kubernetes, and Tilt. In this case, we'll be setting up a local development Kubernetes cluster with a &quot;Hello World&quot; Go microservice. The first step is to use our big brain skills to give it a unique and exciting name:</p>
<pre><code>$ mkdir dating-app-example
$ cd dating-app-example
</code></pre><p>The next step is to initialize our Go service. First, let's make sure Go is installed. You can install Go by following instructions <a href="https://golang.org/doc/install">here</a>, or install it via <a href="https://brew.sh/">homebrew</a>. Now let's initialize the project:</p>
<pre><code>$ go mod init github.com/[username]/dating-app-example
</code></pre><p>To structure the project, I took a few cues from <a href="https://github.com/golang-standards/project-layout">golang-standards/project-layout</a>, with a very simplified version consisting of the following layout:</p>
<pre><code>$ tree
.
├── Dockerfile
├── Tiltfile
├── cmd
│   └── api.go
├── deployments
│   └── api.yaml
├── go.mod
└── internal
</code></pre><p>Don't worry about most of these files yet. In terms of the code we are going to write, the file <code>cmd/api.go</code> will be our executable, and all application code will eventually be kept in <code>internal/</code>. Many projects use <code>pkg/</code> for application code, but since we aren't exposing any of this code as an API to be shared with other projects, we can leave it in <code>internal/</code>.</p>
<p>In the interests of getting our dev environment set up as quickly as possible, we'll stand up a very basic &quot;Hello World&quot; server.</p>
<p>Let's put the following into <code>api.go</code>:</p>
<pre><code>package main

import (
	&quot;log&quot;
	&quot;net/http&quot;
)

func main() {
	http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		w.Write([]byte(&quot;ok&quot;))
	})
	log.Fatal(http.ListenAndServe(&quot;:3000&quot;, nil))
}
</code></pre><p>You can now run this like so:</p>
<pre><code>$ go run cmd/api.go
</code></pre><p>Now open up <code>localhost:3000</code> in your browser. Congratulations, a running program! Even if you're not familiar with Go, this code should be relatively self-explanatory. It specifies a function that runs when you access the server at the root path &quot;/&quot;, and it sends the string &quot;ok&quot; in the response. For a better introduction to the <code>net/http</code> library, Go has excellent <a href="https://golang.org/doc/articles/wiki/#tmp_3">documentation</a>.</p>
<p>Now that that's done, feel free to take a water break. We are going to use a number of brain cells for this tutorial, so it's important to stay hydrated. When you're back, we're going to set up the Kubernetes cluster...</p>
<p>To set up our Kubernetes cluster development environment, we are going to install a tool called <a href="https://docs.tilt.dev/">Tilt</a>. Tilt's main feature as far as I can tell is that it enables a productive dev environment by managing your local Kubernetes cluster and rebuilding containers automatically as you go. It's best suited to multi-service architectures, so it's probably overkill for what we are trying to do right now. Perfect! Go ahead and follow the <a href="https://docs.tilt.dev/install.html">instructions</a> to install it.</p>
<p>In order to use Tilt, we need to have a Kubernetes cluster running on our local machine. If you're on Mac, the fastest way to get that running is to install <a href="https://docs.docker.com/docker-for-mac/install/">Docker for Mac</a>. Once you've got that installed, Docker has a setting to enable Kubernetes. Enable that setting, and eventually you should see a &quot;Kubernetes is running&quot; message when you click on the Docker icon at the top of the screen.</p>
<p>&quot;Why are we using Kubernetes for this dead-simple app?&quot; you may ask. The quick answer is that Kubernetes is a required component when practicing resumé-driven development. That said, one of the nice things about Go is that you can build binaries that run without any dependencies, so if you wanted to skip this tutorial, you could just continue to compile and run the app manually in the terminal as we did before. Given Docker's <a href="https://www.reddit.com/r/docker/comments/bh8rpf/docker_performance_on_macos_vs_native_linux/">abysmal</a> performance on mac, that would probably even save us a few gray hairs.</p>
<p>But that's probably not why you're reading this. The fun starts when we run this app as a Docker container on a local k8s cluster, leveraging Tilt for live updating and k8s for managing our database(s), thus getting us as close as we can to what will eventually be our production environment.</p>
<p>Now that we've got Kubernetes running, we need to set up our Tilt dev environment. For our single Go service, that consists of three things:</p>
<ul>
<li>Dockerfile for the service</li>
<li>Kubernetes deployment yaml file</li>
<li>Tiltfile</li>
</ul>
<p>Let's start with the <code>Dockerfile</code>:</p>
<pre><code>FROM golang:1.14-alpine

RUN apk add --no-cache git

WORKDIR /app

COPY go.mod .
# COPY go.sum .

RUN go mod download

COPY . .

RUN go build -o /app/build/api /app/cmd

CMD [&quot;/app/build/api&quot;]
</code></pre><p>I won't go over the <a href="https://docs.docker.com/get-started/">basics</a> of how Docker works, but the gist is that this copies the code over to the Docker image, downloads any dependencies listed in <code>go.mod</code>, builds the executable, and runs it. Since we'll be building this Docker image frequently during development, there's a &quot;trick&quot; for improving the build performance via the <code>COPY go.mod .</code> command that runs before the main <code>COPY . .</code> command. That allows Docker to cache the list of Go modules so that Docker will only re-download those dependencies if that list changes. NOTE: The <code>go.sum</code> file does not exist because there are no dependencies yet, so you'll want to uncomment that line of the Dockerfile once you've added some dependencies.</p>
<p>Next up, we want to add a basic deployment file for our k8s cluster. We'll call it <code>deployments/api.yaml</code>:</p>
<pre><code>apiVersion: apps/v1
kind: Deployment
metadata:
  name: api
  labels:
    app: api
spec:
  selector:
    matchLabels:
      app: api
  template:
    metadata:
      labels:
        app: api
    spec:
      containers:
        - name: api
          image: dating-app/api
          command: [&quot;/app/build/api&quot;]
          ports:
            - containerPort: 3000
</code></pre><p>This defines a Kubernetes Deployment, the concept of which the <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Kubernetes docs</a> will do a much better job of explaining than I can. In a nutshell, we define a container named <code>api</code> that is built using an image we've defined in our <code>Tiltfile</code> called <code>dating-app/api</code>.</p>
<p>The <code>Tiltfile</code> is a script that orchestrates our dev environment within Kubernetes. We are going to add the following to our <code>Tiltfile</code> in the root directory of the app:</p>
<pre><code>load('ext://restart_process', 'docker_build_with_restart')

k8s_yaml('deployments/api.yaml')

docker_build_with_restart('dating-app/api', '.',
    entrypoint='/app/build/api',
    ignore=['./Dockerfile', '.git'],
    live_update=[
        sync('.', '/app'),
        run('go build -o /app/build/api /app/cmd'),
    ]
)

k8s_resource('api', port_forwards=[3000])
</code></pre><p>Right now this file does 3 things:</p>
<ul>
<li>specifies the locations of the Kubernetes deployment yaml via <code>k8s_yaml()</code></li>
<li>calls <code>docker_build_with_restart()</code> to specify that we want to build a Docker image called <code>dating-app/api</code> (the name we use in the deployment yaml)</li>
<li>sets up port-forwarding to make the app accessible via <code>localhost:3000</code></li>
</ul>
<p>The <code>load()</code> call at the top enables the <code>docker_build_with_restart()</code> feature, which is an important performance optimization because rebuilding the Docker image on every file change can be extremely slow. Instead, using the <code>live_update</code> argument, we sync file changes with the existing container and rebuild the app within the running container. This makes the development cycle snappy, and in my humble opinion, this should be a default rather than an &quot;extension&quot;, because iterative development in Tilt is pretty slow without it.</p>
<p>So without further ado, let's go ahead and fire up Tilt. Open a new terminal tab for your project and run:</p>
<p><code>$ tilt up</code></p>
<p>In the browser, you should see your api container building properly and, once it finishes, the app should be accessible at <code>localhost:3000</code>.</p>
<p>Now we have a working dev environment! Stay tuned for Part 2 of the tutorial, setting up a rudimentary GraphQL API.</p>]]></content>
  </entry>
</feed>
